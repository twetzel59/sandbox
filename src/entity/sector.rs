//! This module implements the basic meshes of the world.
//!
//! The voxel world is made of many blocks, which are chunked,
//! or paged, into sectors that can be loaded individually.
//! These units, or groups of voxels, are called *sectors*,
//! and they are also the smallest section of voxels that
//! will be rendered in one draw call. Thus, each sector
//! is associated with one *Vertex Array Object (VAO)* in
//! OpenGL.

mod data;
mod meshgen;

use crate::maths::matrix::{Mat4x4, Transform, Translation};
use data::SectorData;
use luminance::{context::GraphicsContext, tess::Tess};
use png::OutputInfo;

/// A single sector or "chunk" of the world.
///
/// A ``Sector`` contains an internal array
/// of the blocks within its bounds.
/// 
/// It also keeps track of its position in
/// world coordinates.
///
/// ``Sectors`` optionally hold a ``Tess``
/// that represents their mesh in graphics
/// memory. The mesh is not generated by
/// default on construction.
/// To trigger mesh generation, call the
/// ``gen_geometry`` function.
pub struct Sector {
    translation: Mat4x4,
    data: SectorData,
    geometry: Option<Tess>,
}

impl Sector {
    /// Create a sector filled with the default block.
    ///
    /// Construction does not trigger the creation of the
    /// ``Sector``'s geometry.
    pub fn new(world_pos: (i32, i32, i32)) -> Sector {
        Self::with_data(world_pos, SectorData::new())
    }

    /// Create a sector with the provided voxel data.
    ///
    /// Construction will not result in the creation
    /// of geometry.
    pub fn with_data(world_pos: (i32, i32, i32), sector_data: SectorData) -> Sector {
        Sector {
            translation: Self::calc_mat(world_pos),
            data: sector_data,
            geometry: None,
        }
    }

    /// Returns the transformation of the ``Sector`` from
    /// the world origin.
    pub fn translation(&self) -> &Mat4x4 {
        &self.translation
    }

    /// Trigger the generation of the ``Sector``'s mesh.
    ///
    /// Since this function results in a side effect in
    /// the ``luminance`` backend's state, the graphics
    /// context is needed. It is usually the GLFW window.
    pub fn gen_geometry(&mut self, texture_info: &OutputInfo, ctx: &mut impl GraphicsContext) {
        self.geometry = meshgen::gen_terrain(ctx, texture_info, &self.data);
    }
    
    pub fn test(world_pos: (i32, i32, i32)) -> Sector {
        Self::with_data(world_pos, SectorData::test())
    }
    
    pub fn test_force_geometry(&self) -> &Tess {
        self.geometry.as_ref().unwrap()
    }
    
    fn calc_mat(pos: (i32, i32, i32)) -> Mat4x4 {
        Translation::new((pos.0 as f32, pos.1 as f32, pos.2 as f32)).to_matrix()
    }
}
