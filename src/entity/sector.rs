//! This module implements the basic meshes of the world.
//!
//! The voxel world is made of many blocks, which are chunked,
//! or paged, into sectors that can be loaded individually.
//! These units, or groups of voxels, are called *sectors*,
//! and they are also the smallest section of voxels that
//! will be rendered in one draw call. Thus, each sector
//! is associated with one *Vertex Array Object (VAO)* in
//! OpenGL.

mod data;
mod meshgen;

use crate::maths::{
    matrix::{Mat4x4, Transform, Translation},
    vector::Vec3f,
};
use data::{SectorData, SECTOR_DIM};
use luminance::{context::GraphicsContext, tess::Tess};
use png::OutputInfo;
use std::collections::hash_map::{self, HashMap};

/// Represents the global position of a ``Sector``.
/// Each integer increment represents one sector.
/// Sectors are aligned to their lower-left back corner.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct SectorIndex(pub i32, pub i32, pub i32);

/// Stores all loaded ``Sector``s in the world.
pub struct SectorManager {
    sectors: HashMap<SectorIndex, Sector>,
}

impl SectorManager {
    /// Create a new ``SectorManager`` with no stored
    /// ``Sectors``.
    pub fn new() -> SectorManager {
        SectorManager {
            sectors: HashMap::new(),
        }
    }

    /// Iterate over the sectors in the sector manager.
    pub fn iter(&self) -> SectorManagerIter<'_> {
        self.into_iter()
    }

    /// For development purposes, create the sector with
    /// the given index and force its geometry.
    pub fn test_force_sector(
        &mut self,
        idx: SectorIndex,
        tex_info: &OutputInfo,
        ctx: &mut impl GraphicsContext,
    ) {
        let mut sector = Sector::test(idx);
        sector.gen_geometry(tex_info, ctx);

        self.test_add_sector(idx, sector);
    }

    /// For development purposes, add the given sector
    /// to the manager. The geometry will not be affected.
    pub fn test_add_sector(&mut self, idx: SectorIndex, sector: Sector) {
        println!(
            "{}",
            match sector.geometry {
                SectorGeometry::PendingMeshGen => "PendingMeshGen",
                SectorGeometry::Generated(_) => "Generated(_: Tess)",
                SectorGeometry::GeneratedEmpty => "GeneratedEmpty",
            }
        );

        self.sectors.insert(idx, sector);
    }
}

/// An ``Iterator`` over the ``Sectors`` in a
/// ``SectorManager``.
pub struct SectorManagerIter<'a> {
    inner: hash_map::Iter<'a, SectorIndex, Sector>,
}

impl<'a> Iterator for SectorManagerIter<'a> {
    type Item = (&'a SectorIndex, &'a Sector);

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next()
    }
}

impl<'a> IntoIterator for &'a SectorManager {
    type IntoIter = SectorManagerIter<'a>;
    type Item = (&'a SectorIndex, &'a Sector);

    fn into_iter(self) -> Self::IntoIter {
        SectorManagerIter {
            inner: self.sectors.iter(),
        }
    }
}

/// A single sector or "chunk" of the world.
///
/// A ``Sector`` contains an internal array
/// of the blocks within its bounds.
///
/// It also keeps track of its position in
/// world coordinates.
///
/// ``Sector``s optionally hold a ``Tess``
/// that represents their mesh in graphics
/// memory. The mesh is not generated by
/// default on construction.
/// To trigger mesh generation, call the
/// ``gen_geometry`` function.
pub struct Sector {
    translation: Mat4x4,
    data: SectorData,
    geometry: SectorGeometry,
}

impl Sector {
    /// Create a sector filled with the default block.
    ///
    /// Construction does not trigger the creation of the
    /// ``Sector``'s geometry.
    pub fn new(world_pos: SectorIndex) -> Sector {
        Self::with_data(world_pos, SectorData::new())
    }

    /// Create a sector with the provided voxel data.
    ///
    /// Construction will not result in the creation
    /// of geometry.
    pub fn with_data(world_pos: SectorIndex, sector_data: SectorData) -> Sector {
        Sector {
            translation: Self::calc_mat(world_pos),
            data: sector_data,
            geometry: SectorGeometry::PendingMeshGen,
        }
    }

    /// Returns the transformation of the ``Sector`` from
    /// the world origin.
    pub fn translation(&self) -> &Mat4x4 {
        &self.translation
    }

    /// Trigger the generation of the ``Sector``'s mesh.
    ///
    /// Since this function results in a side effect in
    /// the ``luminance`` backend's state, the graphics
    /// context is needed. It is usually the GLFW window.
    pub fn gen_geometry(&mut self, texture_info: &OutputInfo, ctx: &mut impl GraphicsContext) {
        self.geometry = match meshgen::gen_terrain(ctx, texture_info, &self.data) {
            Some(geo) => SectorGeometry::Generated(geo),
            None => SectorGeometry::GeneratedEmpty,
        };
    }

    /// Return the ``Sector``'s geometry, if it has any.
    ///
    /// ``Sector``s may be fully generated without any
    /// geometry, because some sectors consist of only
    /// air blocks or blocks with no visual representation.
    pub fn geometry(&self) -> Option<&Tess> {
        if let SectorGeometry::Generated(ref tess) = self.geometry {
            Some(tess)
        } else {
            None
        }
    }

    pub fn test(world_pos: SectorIndex) -> Sector {
        Self::with_data(world_pos, SectorData::test())
    }

    fn calc_mat(pos: SectorIndex) -> Mat4x4 {
        let SectorIndex(sx, sy, sz) = pos;
        let pos = Vec3f::new(sx as f32, sy as f32, sz as f32) * SECTOR_DIM as f32;

        Translation::new(pos).to_matrix()
    }
}

/// Represents the tesselation associated with
/// a ``Sector``, if one is needed.
///
/// There are three potential states of a sector's
/// geometry: the geometry has not yet been generated,
/// the sector has been processed and has no geometry
/// (i.e. it is empty), or the sector has a tesselation.
enum SectorGeometry {
    /// The ``Sector``'s data has not been processed by
    /// the mesh generator yet.
    PendingMeshGen,

    /// The ``Sector`` has been processed by the mesh
    /// generator, but there is no geometry for the
    /// ``Sector`` because it contains entirely invisible
    /// blocks (like ``Air``).
    GeneratedEmpty,

    /// The ``Sector`` has a ``Tess`` created by the mesh
    /// generator and can be rendered.
    Generated(Tess),
}
