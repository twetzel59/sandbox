//! This module implements the basic meshes of the world.
//!
//! The voxel world is made of many blocks, which are chunked,
//! or paged, into sectors that can be loaded individually.
//! These units, or groups of voxels, are called *sectors*,
//! and they are also the smallest section of voxels that
//! will be rendered in one draw call. Thus, each sector
//! is associated with one *Vertex Array Object (VAO)* in
//! OpenGL.

mod data;
mod generation;
mod meshgen;

use crate::maths::{
    matrix::{Mat4x4, Transform, Translation},
    vector::Vec3f,
};
use data::{SectorData, SECTOR_DIM_EXCL};
use generation::GenController;
use luminance::{
    context::GraphicsContext,
    tess::{Mode, Tess, TessBuilder},
};
use png::OutputInfo;
use std::collections::hash_map::{self, HashMap};

/// Represents the global position of a ``Sector``.
/// Each integer increment represents one sector.
/// Sectors are aligned to their lower-left back corner.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct SectorIndex(pub i32, pub i32, pub i32);

/// A single sector or "chunk" of the world.
///
/// A ``Sector`` contains an internal array
/// of the blocks within its bounds.
///
/// It also keeps track of its position in
/// world coordinates.
///
/// ``Sector``s optionally hold a ``Tess``
/// that represents their mesh in graphics
/// memory. The mesh is not generated by
/// default on construction.
/// To trigger mesh generation, call the
/// ``gen_geometry`` function.
pub struct Sector {
    translation: Mat4x4,
    data: SectorData,
    geometry: Option<Tess>,
}

impl Sector {
    /// Create a sector with the provided voxel data.
    pub fn new(world_pos: SectorIndex, sector_data: SectorData, geometry: Option<Tess>) -> Sector {
        Sector {
            translation: Self::calc_mat(world_pos),
            data: sector_data,
            geometry,
        }
    }

    /// Returns the transformation of the ``Sector`` from
    /// the world origin.
    pub fn translation(&self) -> &Mat4x4 {
        &self.translation
    }

    /// Return the ``Sector``'s geometry, if it has any.
    ///
    /// ``Sector``s may be fully generated without any
    /// geometry, because some sectors consist of only
    /// air blocks or blocks with no visual representation.
    pub fn geometry(&self) -> Option<&Tess> {
        self.geometry.as_ref()
    }

    /// Returns the ``SectorData`` for this instance.
    fn data(&self) -> &SectorData {
        &self.data
    }

    fn calc_mat(pos: SectorIndex) -> Mat4x4 {
        let SectorIndex(sx, sy, sz) = pos;
        let pos = Vec3f::new(sx as f32, sy as f32, sz as f32) * SECTOR_DIM_EXCL as f32;

        Translation::new(pos).to_matrix()
    }
}

/// Stores all loaded ``Sector``s in the world.
pub struct SectorManager {
    sectors: HashMap<SectorIndex, Sector>,
    generator: GenController,
}

impl SectorManager {
    /// Create a new ``SectorManager`` with no stored
    /// ``Sectors``.
    pub fn new(tex_info: &OutputInfo) -> SectorManager {
        SectorManager {
            sectors: HashMap::new(),
            generator: GenController::launch(tex_info),
        }
    }

    /// Finish generating a sector whose terrain and geometry
    /// has been generated in the worldgen thread, if the
    /// sector is ready.
    pub fn finalize_sectors(&mut self, ctx: &mut impl GraphicsContext) {
        match self.generator.receiver().try_recv() {
            Ok(message) => {
                let tess = message.pre_geometry.map(|pre_geo| {                    
                    TessBuilder::new(ctx)
                        .add_vertices(pre_geo.vertices)
                        .set_indices(pre_geo.indices)
                        .set_mode(Mode::Triangle)
                        .build()
                        .unwrap()
                });

                let new_sector = Sector::new(message.world_pos, message.sector_data, tess);

                self.sectors.insert(message.world_pos, new_sector);
            }
            Err(_) => {}
        }
    }

    /// Iterate over the sectors in the sector manager.
    pub fn iter(&self) -> SectorManagerIter<'_> {
        self.into_iter()
    }
}

/// An ``Iterator`` over the ``Sectors`` in a
/// ``SectorManager``.
pub struct SectorManagerIter<'a> {
    inner: hash_map::Iter<'a, SectorIndex, Sector>,
}

impl<'a> Iterator for SectorManagerIter<'a> {
    type Item = (&'a SectorIndex, &'a Sector);

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next()
    }
}

impl<'a> IntoIterator for &'a SectorManager {
    type IntoIter = SectorManagerIter<'a>;
    type Item = (&'a SectorIndex, &'a Sector);

    fn into_iter(self) -> Self::IntoIter {
        SectorManagerIter {
            inner: self.sectors.iter(),
        }
    }
}
